/********************************************************************
 *	TCP/UDP????????????
 * @file test_m8266wifi.c		??main.c?¡ì????M8266WIFI_Test()????
 * @brief Source file of M8266WIFI testing application (M8266WIFI???????????)
 ********************************************************************/

#include "stdio.h"
#include "brd_cfg.h"
#include "M8266WIFIDrv.h"
#include "M8266HostIf.h"
#include "M8266WIFI_ops.h"
#include "led.h"

//#define USE_LED_AND_KEY_FOR_TEST	//???LED????????¡ì????,?????

void M8266WIFI_Test(void)
{
	u16 i;	//?????led?????for()???????????
	u16 status = 0;		//??????????????
	u8  link_no = 0;	//???¡è??
	u8	link_no1 = 1;	//???¡è1

	// ????????????????LED?????4?????????????????¡ì????????????????????????????????????
	// ????¡ì?????USE_LED_AND_KEY_FOR_TEST??????????????????
	#ifdef USE_LED_AND_KEY_FOR_TEST		//?????
	{
		for(i=0; i<3; i++)
		{                    
			LED_set(0, 0); LED_set(1, 1);  M8266WIFI_Module_delay_ms(100);
			LED_set(0, 1); LED_set(1, 0);  M8266WIFI_Module_delay_ms(100);
			LED_set(0, 0); LED_set(1, 1);  M8266WIFI_Module_delay_ms(100);
			LED_set(0, 1); LED_set(1, 0);  M8266WIFI_Module_delay_ms(100);
		}
		LED_set(0, 1); LED_set(1, 1);
	}
	#endif	 
	//



	//----------------------------------------------------------------------------------
	//		1. ?????????(socket)??????¡ì??? (?¡ì????????????????)
	//----------------------------------------------------------------------------------
	/*		??????¡§????
		????1.STM32F1-M8266WIFI
		????5.1.WiFi???AP????PC???STA?????????????????¡è????????????1????????OK
		????5.2.WiFi???AP????PC???STA?????????????????¡è????????????????????OK
		????5.3.WiFi???STA????PC???AP????PC??????????????????¡è????????????1????????OK
		????5.4.WiFi???STA????TCP??????---??????¡è??????---PC??TCP????????OK
		????5.5.WiFi??????????WiFi???AP????//OK
	*/
	// ?????WiFi??????????
	#define TEST_M8266WIFI_TYPE 1 //1=?????????????? | 2=???????????? | 3=?????????????????????? | 4=?????????

	// ?????WiFi??????(TCD/UDP-Server/Client)
	#define TEST_CONNECTION_TYPE 1	// 0 = WIFI?????UDP | 1 = WIFI?????TCP????? | 2 = WIFI?????TCP??????

	/*	local port (???????????)	*/
	#if (TEST_CONNECTION_TYPE == 1)	//??????TCP?????
		// ???????????
		#define TEST_LOCAL_PORT 0	//??local port?????????0???????????????????????????????????????????????????????¡§??????????????????????????????????????????????????????????????????????????
	#elif (TEST_CONNECTION_TYPE == 0) || (TEST_CONNECTION_TYPE == 2)
		// ??????????????????
		#define TEST_LOCAL_PORT 4321  //??????UDP??TCP?????????????????????????????
	#else
		#error WRONG TEST_CONNECTION_TYPE defined !
	#endif

		/*	remote port (?????????????????????)	*/
	#if (TEST_CONNECTION_TYPE == 0)	 	// ??????UDP??????????????????????????????????????????????????
		#define TEST_REMOTE_ADDR	"192.168.4.2"
		#define TEST_REMOTE_PORT 	1234
	#elif (TEST_CONNECTION_TYPE == 1)	//??????TCP?????????????????ip??port????????????????TCP????????ip??port
		#define TEST_REMOTE_ADDR	"192.168.43.18"	//192.168.43.18
		#define TEST_REMOTE_PORT	1211
	#elif (TEST_CONNECTION_TYPE == 2)	//??????TCP??????,????????????????????????????????????????????¡ì???
		#define TEST_REMOTE_ADDR	"1.1.1.1"	//???IP192.168.4.1?????4321??
		#define TEST_REMOTE_PORT	1234
	#else
		#error WRONG TEST_CONNECTION_TYPE defined !
	#endif
	// Note:?????WIFI?????TCP??????????????????4321????????????????????(ip:port)?????¡ã¨¦??



	//----------------------------------------------------------------------------------
	//	 	2. ??????????????????????????¡ì?????(???n??UDP??TCP)
	//----------------------------------------------------------------------------------	 

	// Note:????1???????TCP?????????????????????????????	(step 0: config tcp windows number)
	#if ( 1 && ((TEST_CONNECTION_TYPE==1) || (TEST_CONNECTION_TYPE==2)) ) //?????????????????????????#if????¡ì??0???1???????????????????????????
		if(M8266WIFI_SPI_Config_Tcp_Window_num(link_no, 4, &status)==0)
		{
			while(1)
			{
				#ifdef USE_LED_AND_KEY_FOR_TEST	 // ??????? 1Hz ????????
				LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(100);
				LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(100);
				#endif
			}
		}
		//*******************************
		#if 0	//link_no1
		if(M8266WIFI_SPI_Config_Tcp_Window_num(link_no1, 4, &status)==0)
		{
			while(1) 
			{
				#ifdef USE_LED_AND_KEY_FOR_TEST	 // ??????? 1Hz ????????
				LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(100);
				LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(100);
				#endif
			}
		}
		#endif	//link_no1
		//*******************************
	#endif

	// Note:????2???????????????
	if(M8266WIFI_SPI_Setup_Connection(TEST_CONNECTION_TYPE, TEST_LOCAL_PORT, TEST_REMOTE_ADDR, TEST_REMOTE_PORT, link_no, 20, &status)==0)
	{
		while(1)
		{
			#ifdef USE_LED_AND_KEY_FOR_TEST	 // ????????????????????????????1Hz???????????
			LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(500);
			LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(500);
			#endif
		}
	}
	else  // ???????????????????????????
	{
		// ?????????????UDP????????????¡§??????????????????¡§????????????#if????¡ì??????'0'???'1'
		#if ( 0 && (TEST_CONNECTION_TYPE == 0) )	//(#1)
		//u8 M8266WIFI_SPI_Set_Multicuast_Group(u8 join_not_leave, char multicust_group_ip[15+1], u16* status)
		if(M8266WIFI_SPI_Op_Multicuast_Group(0, "224.6.6.6", &status)==0)
		{
			while(1)
			{
				#ifdef USE_LED_AND_KEY_FOR_TEST   // ??????????????????????????????
				LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(1000);
				LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(1000);
				#endif				 
			}
		}
		else	//!!! {} ???

		//  ???TCP??????????????????????TCP??????(???????????)??????????????
		//(If TCP server, then tcp server auto disconnection timeout, and max clients allowed could be set)
		#elif (TEST_CONNECTION_TYPE == 2)	//(#2)
		
			#if 1	//(#2.1a)	//(TEST_CONNECTION_TYPE == 2) == 1
			//??¡è???????????u8 M8266WIFI_SPI_Set_TcpServer_Auto_Discon_Timeout(u8 link_no, u16 timeout_in_s, u16* status)	
			//(#IF)
			if( M8266WIFI_SPI_Set_TcpServer_Auto_Discon_Timeout(link_no, 120, &status) == 0)
			{
				while(1)
				{
					#ifdef USE_LED_AND_KEY_FOR_TEST	// led flash in 1Hz when error
					LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(1000);
					LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(1000);
					#endif		 
				}
			}
			#endif	//(#2.1b)
	
			#if 0	//(#2.2a)	//(TEST_CONNECTION_TYPE == 2) == 0
			//u8 M8266WIFI_SPI_Config_Max_Clients_Allowed_To_A_Tcp_Server(u8 server_link_no, u8 max_allowed, u16* status);
			else if( M8266WIFI_SPI_Config_Max_Clients_Allowed_To_A_Tcp_Server(link_no, 5, &status)==0)
			{
				while(1)
				{
					#ifdef USE_LED_AND_KEY_FOR_TEST	// led flash in 1Hz when error
					LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(1000);
					LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(1000);
					#endif		 
				}
			}
			#endif	//(#2.2b)

			else	//(#ELSE)
		#endif	//(#3)		//Setup Connection successfully (???????????????)
		{
			#ifdef USE_LED_AND_KEY_FOR_TEST		// led 1 flash 4 times upon success 
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
			#endif			 
		}
	}
	//*******************************
	#if 0	// link_no1
	if(M8266WIFI_SPI_Setup_Connection(TEST_CONNECTION_TYPE, TEST_LOCAL_PORT, TEST_REMOTE_ADDR, TEST_REMOTE_PORT, link_no1, 20, &status)==0)
	{
		while(1)
		{
			#ifdef USE_LED_AND_KEY_FOR_TEST	 // ????????????????????????????1Hz???????????
			LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(500);
			LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(500);
			#endif
		}
	}
	else  // ???????????????????????????
	{
		// ?????????????UDP????????????¡§??????????????????¡§????????????#if????¡ì??????'0'???'1'
		#if ( 0 && (TEST_CONNECTION_TYPE == 0) )	//(#1)
		//u8 M8266WIFI_SPI_Set_Multicuast_Group(u8 join_not_leave, char multicust_group_ip[15+1], u16* status)
		if(M8266WIFI_SPI_Op_Multicuast_Group(0, "224.6.6.6", &status)==0)
		{
			while(1)
			{
				#ifdef USE_LED_AND_KEY_FOR_TEST   // ??????????????????????????????
				LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(1000);
				LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(1000);
				#endif				 
			}
		}
		else	//!!! {} ???

		//  ???TCP??????????????????????TCP??????(???????????)??????????????
		//(If TCP server, then tcp server auto disconnection timeout, and max clients allowed could be set)
		#elif (TEST_CONNECTION_TYPE == 2)	//(#2)
		
			#if 1	//(#2.1a)	//(TEST_CONNECTION_TYPE == 2) == 1
			//??¡è???????????u8 M8266WIFI_SPI_Set_TcpServer_Auto_Discon_Timeout(u8 link_no, u16 timeout_in_s, u16* status)	
			//(#IF)
			if( M8266WIFI_SPI_Set_TcpServer_Auto_Discon_Timeout(link_no1, 120, &status) == 0)
			{
				while(1)
				{
					#ifdef USE_LED_AND_KEY_FOR_TEST	// led flash in 1Hz when error
					LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(1000);
					LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(1000);
					#endif		 
				}
			}
			#endif	//(#2.1b)
	
			#if 0	//(#2.2a)	//(TEST_CONNECTION_TYPE == 2) == 0
			//u8 M8266WIFI_SPI_Config_Max_Clients_Allowed_To_A_Tcp_Server(u8 server_link_no, u8 max_allowed, u16* status);
			else if( M8266WIFI_SPI_Config_Max_Clients_Allowed_To_A_Tcp_Server(link_no1, 5, &status)==0)
			{
				while(1)
				{
					#ifdef USE_LED_AND_KEY_FOR_TEST	// led flash in 1Hz when error
					LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(1000);
					LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(1000);
					#endif		 
				}
			}
			#endif	//(#2.2b)

			else	//(#ELSE)
		#endif	//(#3)		//Setup Connection successfully (???????????????)
		{
			#ifdef USE_LED_AND_KEY_FOR_TEST		// led 1 flash 4 times upon success 
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
		   	LED_set(1, 0); M8266WIFI_Module_delay_ms(50); LED_set(1, 1); M8266WIFI_Module_delay_ms(50);
			#endif			 
		}
	}
	#endif	//link_no1
	//*******************************




	//----------------------------------------------------------------------------------
	//	3. WIFI??????????????????? (TCP/UDP??Server/Client??????)
	//??1????????????????????????????????????????????????	Yes
	//??2??????????????????????????????????????????????	No
	//??3??????????????????????????????????????????????????????????????????????????????No
	//??4????????????	No
	//----------------------------------------------------------------------------------

	/*	1. ????????????????????????	*/
	#if (TEST_M8266WIFI_TYPE == 1) // Transmission Test: to test send data to remote constantly 
	{
		// ?????????????¡­????????????????????????????????????. ?????????????????????????????????hardware fault"????
		#define TEST_SEND_DATA_SIZE  200 //2920 //5840 //2048 // 1024		
		u8 snd_data[TEST_SEND_DATA_SIZE];		//TCP???????¡ì?
		volatile u32 sent = 0;
		volatile u32 total_sent = 0, MBytes = 0; 
		u16 batch;
		volatile u8 debug_point;
		u16 TEXT_Buffer[40]={0};
		int at=0;
		u16 i,j;

		for(i = 0; i < 40; i++)	{ TEXT_Buffer[i]=i; }	//??????????????

		for(j = 0; j < 40; j += 2)
		{
			snd_data[10*at+0]=(char)(((TEXT_Buffer[j])/1000)+48);
			snd_data[10*at+1]=(char)((((TEXT_Buffer[j])/100)%10)+48);
			snd_data[10*at+2]=(char)((((TEXT_Buffer[j])%100)/10)+48);
			snd_data[10*at+3]=(char)(((TEXT_Buffer[j])%10)+48);
			snd_data[10*at+4]=' ';
			snd_data[10*at+5]=(char)(((TEXT_Buffer[j+1])/1000)+48);
			snd_data[10*at+6]=(char)((((TEXT_Buffer[j+1])/100)%10)+48);
			snd_data[10*at+7]=(char)((((TEXT_Buffer[j+1])%100)/10)+48);
			snd_data[10*at+8]=(char)(((TEXT_Buffer[j+1])%10)+48);
			snd_data[10*at+9]=' ';
			at++;
			// j += 2;	//????for()?????
		}
	
		// ?????????????????????????????????? (Generate an array of data to transmit) 
		// for(i=0; i<TEST_SEND_DATA_SIZE; i++) { snd_data[i]=i; }
		
		link_no = 0;
		
		for(batch = 0; ; batch++)
		{
			// below used to convenient reception end to differentiate packets when test and evaluate the reliability of transmission. Not necessary.
			// (??????????????????????????????????????????????????????????????????????????????????????????)
			
			/*	??????????????¡­??????????????????????(first two bytes using batch to differentiate the continuos packets) 	*/
			// snd_data[0]= batch>>8;
			// snd_data[1]= batch&0xFF; 
			
			/*	?????????????????¡­??????????????????????????????????????????????? FF FF???????????????????????????????????????FF FF????????????????????FF FF???????????????????????????????	*/
			/*	last byte using customized to label end of a packet for the sake of searching for data verification. Here FF FF as an example	*/ 
			// snd_data[TEST_SEND_DATA_SIZE-2]=0xFF;
			// snd_data[TEST_SEND_DATA_SIZE-1]=0xFF;

			if(total_sent > 1024*1024)  // watch MBytes*1024*1024+total_sent, which is the count of data module sends, compared with the received count at the reception end, to determin the packet loss etc
			{                          // (????????????????????? MBytes*1024*1024+total_sent ???????????????????????????¡ì????????????????????????)
				MBytes++;
				total_sent -= 1024*1024;
			}

			// ????M8266WIFI_SPI_Send_BlockData()???????????? 
			#if 1  //(#1)	//???#if (TEST_M8266WIFI_TYPE == 1)?????¡ì??
			{
				// u32 M8266WIFI_SPI_Send_BlockData(u8 Data[], u32 Data_len, u16 max_loops, u8 link_no, char* remote_ip, u16 remote_port, u16* status);
				// ??????¡ì?TI/IAP??????????????????MSP430, K60??TMS28335,????????????Data_len??????32????????????????????????????2^16??????????????????????????u32??????(u32)TEST_SEND_DATA_SIZE?????? 2048UL ???????????????????????????¡À??????????????????TI??IAR???¡ì??????????????
				// PLEASE add (u32) to mandatorily convert a const to u32, or, the parameter transmission will be 16-bit and bring about function calling failure
				sent = M8266WIFI_SPI_Send_BlockData(snd_data, (u32)TEST_SEND_DATA_SIZE, 5000, link_no, NULL, 0, &status); 
				
				total_sent += sent;

				if( (sent==TEST_SEND_DATA_SIZE) && ((status&0xFF)==0x00) ) //??????
				{
					
				}
				else if( (status&0xFF) == 0x1E)	// 0x1E = too many errors encountered during sending and can not fixed, or transsmission blocked heavily(??????????????????????????????????max_loops)
				{
					debug_point = 1;
					//add some process here (???????????¡ì???????????????max_loops???)
				}
				//	0x14 = connection of link_no not present (????????????)
				//	0x15 = connection of link_no closed(????????????????)
				else if( ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )			
				{
					debug_point = 2;
					//???????????????????
				}
				else if( (status&0xFF) == 0x18 )	// 0x18 = TCP server in listening states and no tcp clients have connected. (???TCP??????????¡ì¨¢????????????)
				{
					debug_point = 3;
					M8266HostIf_delay_us(99);
				}
				else {
					debug_point = 4;
					M8266HostIf_delay_us(101);
				}
			}//end of #if 1
		
			// ????M8266WIFI_SPI_Send_Data() ??????????????????????????????M8266WIFI_SPI_Send_BlockData()???????????
			#else	//(#2)	//???#if (TEST_M8266WIFI_TYPE == 1)?????¡ì??
			{
				u16 tcp_packet_size = 1024;
				u16 loops     = 0;
				u16 max_loops = 5000;
				u32 len       = TEST_SEND_DATA_SIZE; 
					
				for(sent=0, loops=0; (sent<len)&&(loops<=max_loops); loops++)
				{		
					sent += M8266WIFI_SPI_Send_Data(snd_data+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no, &status);
					if(sent>=len)  break;
					if((status&0xFF) == 0x00) { loops = 0; }
					else
					{
						/*	0x14 = connection of link_no not present (????????????)
							0x15 = connection of link_no closed(????????????????)	*/
						if(   ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )
						{
							M8266HostIf_delay_us(99);
							//need to re-establish the socket connection (???????????????)
						}
						// 0x18 = TCP server in listening states and no tcp clients have connected. (???TCP??????????¡ì¨¢????????????)
						else if( (status&0xFF) == 0x18 ) { M8266HostIf_delay_us(100); }
						else { M8266HostIf_delay_us(250); }
					}
				} // end of for(...		
				total_sent += sent;
			}//end of #else

			#endif	//(#3)	
		} //end of for()
		//*****************************************************
		#if 0	// link_no1
		link_no1 = 1;
		for(batch = 0; ; batch++)
		{
			// below used to convenient reception end to differentiate packets when test and evaluate the reliability of transmission. Not necessary.
			// (??????????????????????????????????????????????????????????????????????????????????????????)
			
			/*	??????????????¡­??????????????????????(first two bytes using batch to differentiate the continuos packets) 	*/
			// snd_data[0]= batch>>8;
			// snd_data[1]= batch&0xFF; 
			
			/*	?????????????????¡­??????????????????????????????????????????????? FF FF???????????????????????????????????????FF FF????????????????????FF FF???????????????????????????????	*/
			/*	last byte using customized to label end of a packet for the sake of searching for data verification. Here FF FF as an example	*/ 
			// snd_data[TEST_SEND_DATA_SIZE-2]=0xFF;
			// snd_data[TEST_SEND_DATA_SIZE-1]=0xFF;

			if(total_sent > 1024*1024)  // watch MBytes*1024*1024+total_sent, which is the count of data module sends, compared with the received count at the reception end, to determin the packet loss etc
			{                          // (????????????????????? MBytes*1024*1024+total_sent ???????????????????????????¡ì????????????????????????)
				MBytes++;
				total_sent -= 1024*1024;
			}

			// ????M8266WIFI_SPI_Send_BlockData()???????????? 
			#if 1  //(#1)	//???#if (TEST_M8266WIFI_TYPE == 1)?????¡ì??
			{
				// u32 M8266WIFI_SPI_Send_BlockData(u8 Data[], u32 Data_len, u16 max_loops, u8 link_no, char* remote_ip, u16 remote_port, u16* status);
				// ??????¡ì?TI/IAP??????????????????MSP430, K60??TMS28335,????????????Data_len??????32????????????????????????????2^16??????????????????????????u32??????(u32)TEST_SEND_DATA_SIZE?????? 2048UL ???????????????????????????¡À??????????????????TI??IAR???¡ì??????????????
				// PLEASE add (u32) to mandatorily convert a const to u32, or, the parameter transmission will be 16-bit and bring about function calling failure
				sent = M8266WIFI_SPI_Send_BlockData(snd_data, (u32)TEST_SEND_DATA_SIZE, 5000, link_no1, NULL, 0, &status); 
				
				total_sent += sent;

				if( (sent==TEST_SEND_DATA_SIZE) && ((status&0xFF)==0x00) ) //??????
				{
					
				}
				else if( (status&0xFF) == 0x1E)	// 0x1E = too many errors encountered during sending and can not fixed, or transsmission blocked heavily(??????????????????????????????????max_loops)
				{
					debug_point = 1;
					//add some process here (???????????¡ì???????????????max_loops???)
				}
				//	0x14 = connection of link_no not present (????????????)
				//	0x15 = connection of link_no closed(????????????????)
				else if( ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )			
				{
					debug_point = 2;
					//???????????????????
				}
				else if( (status&0xFF) == 0x18 )	// 0x18 = TCP server in listening states and no tcp clients have connected. (???TCP??????????¡ì¨¢????????????)
				{
					debug_point = 3;
					M8266HostIf_delay_us(99);
				}
				else {
					debug_point = 4;
					M8266HostIf_delay_us(101);
				}
			}//end of #if 1
		
			// ????M8266WIFI_SPI_Send_Data() ??????????????????????????????M8266WIFI_SPI_Send_BlockData()???????????
			#else	//(#2)	//???#if (TEST_M8266WIFI_TYPE == 1)?????¡ì??
			{
				u16 tcp_packet_size = 1024;
				u16 loops     = 0;
				u16 max_loops = 5000;
				u32 len       = TEST_SEND_DATA_SIZE; 
					
				for(sent=0, loops=0; (sent<len)&&(loops<=max_loops); loops++)
				{		
					sent += M8266WIFI_SPI_Send_Data(snd_data+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no, &status);
					if(sent>=len)  break;
					if((status&0xFF) == 0x00) { loops = 0; }
					else
					{
						/*	0x14 = connection of link_no not present (????????????)
							0x15 = connection of link_no closed(????????????????)	*/
						if(   ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )
						{
							M8266HostIf_delay_us(99);
							//need to re-establish the socket connection (???????????????)
						}
						// 0x18 = TCP server in listening states and no tcp clients have connected. (???TCP??????????¡ì¨¢????????????)
						else if( (status&0xFF) == 0x18 ) { M8266HostIf_delay_us(100); }
						else { M8266HostIf_delay_us(250); }
					}
				} // end of for(...		
				total_sent += sent;
			}//end of #else

			#endif	//(#3)	
		} //end of for()
		#endif	// link_no1
	}
	//*************************************************************************



	/*	2. ????????????????????????????????	*/
	#elif (TEST_M8266WIFI_TYPE == 2)  // to test constant reception from remote
	{
		// ?????????????¡­????????????????????????????????????. ?????????????????????????????????hardware fault"????	
		#define RECV_DATA_MAX_SIZE  2048
		u8  RecvData[RECV_DATA_MAX_SIZE];
		u16 received = 0;                   
		u32 total_received = 0;
		u32 MBytes = 0;
		
		for(i = 0; i < RECV_DATA_MAX_SIZE; i++)	{ RecvData[i] = 0xFF-i; }

		// (?????????????????????????????IP?????????????) 
		M8266WIFI_SPI_Send_Data(RecvData, 1024, link_no, &status);	//???F??????TCP????????? IP ????? ????

		while(1)
		{
			if(M8266WIFI_SPI_Has_DataReceived())
			{
				//u16 M8266WIFI_SPI_RecvData(u8 data[], u16 max_len, uint16_t max_wait_in_ms, u8* link_no, u16* status);
				received = M8266WIFI_SPI_RecvData(RecvData, RECV_DATA_MAX_SIZE, 5*1000, &link_no, &status);

				if( (status&0xFF)!= 0 )  
				{
					if( (status&0xFF)==0x22 )	// 0x22 = Module buffer has no data received
					{  
						M8266HostIf_delay_us(250); 
						//M8266WIFI_Module_delay_ms(1);
					}
					else if( (status&0xFF)==0x23 )   
					{ 
						/*
							the packet had not been received completed in the last call of M8266WIFI_SPI_RecvData()
							and has continued to be received in this call of M8266WIFI_SPI_RecvData() 
							do some work here if necessary
							?????????????M8266WIFI_SPI_RecvData()?????????????????????????????????¡§???????????????
							?????????????¡ì???????????L?????????????????????????
						*/
					}
					else if( (status&0xFF)==0x24 )   
					{ 
						/*
							the packet is large in size than max_len specified and received only the max_len. 
							normally caused by the burst transmission by the routers after some block. 
							Suggest to stop the TCP transmission for some time.	do some work here if necessary
							????????????????????????????????????????????max_len???????????????
							??????????????????¡è??????????????????????????????????????????
							???????????????????????????????????????????????????????
							?????????????????????TCP?????????
							???????????????max_len???????????????????????????????????????????????????????????¡ì????????????????
							????????????????????
						*/
					}
					else {	
						/*	do some work here if necessary(???????????????????¡ì???????)	*/ 
					}
				}

				#define  TEST_RECV_UNIT (1024*1024)
				total_received += received;
				if( total_received >= (TEST_RECV_UNIT) )
				{
					LED_set(0, MBytes & 0x01);	
					total_received = total_received % (TEST_RECV_UNIT);
					MBytes++;
				}
			} // end of if(M8266WIFI_SPI_Has_DataReceived())				 
		} // end of while(1)

		#if 0	// link_no1
		M8266WIFI_SPI_Send_Data(RecvData, 1024, link_no1, &status);	//???F??????TCP????????? IP ????? ????

		while(1)
		{
			if(M8266WIFI_SPI_Has_DataReceived())
			{
				//u16 M8266WIFI_SPI_RecvData(u8 data[], u16 max_len, uint16_t max_wait_in_ms, u8* link_no, u16* status);
				received = M8266WIFI_SPI_RecvData(RecvData, RECV_DATA_MAX_SIZE, 5*1000, &link_no1, &status);

				if( (status&0xFF)!= 0 )  
				{
					if( (status&0xFF)==0x22 )	// 0x22 = Module buffer has no data received
					{  
						M8266HostIf_delay_us(250); 
						//M8266WIFI_Module_delay_ms(1);
					}
					else if( (status&0xFF)==0x23 )   
					{ 
						/*
							the packet had not been received completed in the last call of M8266WIFI_SPI_RecvData()
							and has continued to be received in this call of M8266WIFI_SPI_RecvData() 
							do some work here if necessary
							?????????????M8266WIFI_SPI_RecvData()?????????????????????????????????¡§???????????????
							?????????????¡ì???????????L?????????????????????????
						*/
					}
					else if( (status&0xFF)==0x24 )   
					{ 
						/*
							the packet is large in size than max_len specified and received only the max_len. 
							normally caused by the burst transmission by the routers after some block. 
							Suggest to stop the TCP transmission for some time.	do some work here if necessary
							????????????????????????????????????????????max_len???????????????
							??????????????????¡è??????????????????????????????????????????
							???????????????????????????????????????????????????????
							?????????????????????TCP?????????
							???????????????max_len???????????????????????????????????????????????????????????¡ì????????????????
							????????????????????
						*/
					}
					else {	
						/*	do some work here if necessary(???????????????????¡ì???????)	*/ 
					}
				}

				#define  TEST_RECV_UNIT (1024*1024)
				total_received += received;
				if( total_received >= (TEST_RECV_UNIT) )
				{
					LED_set(0, MBytes & 0x01);	
					total_received = total_received % (TEST_RECV_UNIT);
					MBytes++;
				}
			} // end of if(M8266WIFI_SPI_Has_DataReceived())				 
		} // end of while(1)
		#endif	// link_no1
	} //end of #elif



	/*	3. ???????????q????????????????????????	*/
	#elif (TEST_M8266WIFI_TYPE == 3)  // Echo test: to receive data from remote and then echo back to remote
	{
		// ?????????????¡­????????????????????????????????????. ?????????????????????????????????hardware fault"????
		#define  RECV_DATA_MAX_SIZE  2048
		u8  RecvData[RECV_DATA_MAX_SIZE];
		u16 received = 0;
		u16 sent;
		
		for(i = 0; i < RECV_DATA_MAX_SIZE; i++)	{ RecvData[i] = i; }

		link_no = 0;
		sent = M8266WIFI_SPI_Send_Data(RecvData, 1024, link_no, &status);

		while(1)
		{
			if(M8266WIFI_SPI_Has_DataReceived()) // ????????????
			{
				//u16 M8266WIFI_SPI_RecvData(u8 data[], u16 max_len, uint16_t max_wait_in_ms, u8* link_no, u16* status);
				received = M8266WIFI_SPI_RecvData(RecvData, RECV_DATA_MAX_SIZE, 5*1000, &link_no, &status);

				if(received!=0) //?????????????????????????0???????????????
				{
					u16 tcp_packet_size = 1024;
					u16 loops     = 0;
					u16 max_loops = 5000;
					u32 len       = received; 
				
					for(sent=0, loops=0; (sent<len)&&(loops<=max_loops); loops++)
					{		
						sent += M8266WIFI_SPI_Send_Data(RecvData+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no, &status);
						if(sent >= len)  break;
						if((status&0xFF) == 0x00)	{ loops = 0; }
						else
						{
							/*	0x14 = connection of link_no not present (????????????)
								0x15 = connection of link_no closed(????????????????) */
							if( ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )
							{
								M8266HostIf_delay_us(99);
								//need to re-establish the socket connection (???????????????????)
							}
							else if( (status&0xFF) == 0x18 )	{ M8266HostIf_delay_us(100); }	//0x18-TCP???????????????????????¡ì¨¢????????????
							else	{ M8266HostIf_delay_us(250); }
						} // end of else
					} // end of for(...
				} // end of if(received!=0)
			}
		} // end of while(1)

		#if 0	// link_no1
		link_no1 = 1;
		sent = M8266WIFI_SPI_Send_Data(RecvData, 1024, link_no1, &status);

		while(1)
		{
			if(M8266WIFI_SPI_Has_DataReceived()) // ????????????
			{
				//u16 M8266WIFI_SPI_RecvData(u8 data[], u16 max_len, uint16_t max_wait_in_ms, u8* link_no, u16* status);
				received = M8266WIFI_SPI_RecvData(RecvData, RECV_DATA_MAX_SIZE, 5*1000, &link_no1, &status);

				if(received!=0) //?????????????????????????0???????????????
				{
					u16 tcp_packet_size = 1024;
					u16 loops     = 0;
					u16 max_loops = 5000;
					u32 len       = received; 
				
					for(sent=0, loops=0; (sent<len)&&(loops<=max_loops); loops++)
					{		
						sent += M8266WIFI_SPI_Send_Data(RecvData+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no, &status);
						if(sent >= len)  break;
						if((status&0xFF) == 0x00)	{ loops = 0; }
						else
						{
							/*	0x14 = connection of link_no1 not present (????????????)
								0x15 = connection of link_no1 closed(????????????????) */
							if( ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )
							{
								M8266HostIf_delay_us(99);
								//need to re-establish the socket connection (???????????????????)
							}
							else if( (status&0xFF) == 0x18 )	{ M8266HostIf_delay_us(100); }	//0x18-TCP???????????????????????¡ì¨¢????????????
							else {	M8266HostIf_delay_us(250);	}
						} // end of else
					} // end of for(...
				} // end of if(received!=0)
			}
		} // end of while(1)
		#endif	// link_no1
	}// end of #elif



	/*	4. ????????????????????TCP????????UDP????????????????????????????????????????????????????????	*/
	#elif (TEST_M8266WIFI_TYPE == 4) // multi-clients transimission test: TCP Server or UDP receive data from multilple sender and echo back the data to the coresponding source
	{
		#if ( (TEST_CONNECTION_TYPE!=0) && (TEST_CONNECTION_TYPE!=2) )
		#error multiple clients test could be supported only when socket connection is UDP or TCP Server
		#endif

		//BUG: ??????(TEST_M8266WIFI_TYPE == 4)????????
		#define RECV_DATA_MAX_SIZE  2048
		/*	?????????????¡­????????????????????????????????????. ?????????????????????????????????hardware fault"????	*/
		/*	If using large size of array, ensure system stack is large enough for the array variable?? Or stack over-bound leakage might bring about the mcu into "hardware fault exception" 	*/
		u8  RecvData[RECV_DATA_MAX_SIZE];
		u16 received = 0;
		u16 sent;
		u8  remote_ip[4];
		u16 remote_port;
		
		for(i = 0; i < RECV_DATA_MAX_SIZE; i++)	{ RecvData[i]=i; }

		link_no = 0;

		while(1)
		{
			if(M8266WIFI_SPI_Has_DataReceived()) // ????????????
			{
				/*	???????¡§????M8266WIFI_SPI_RecvData_ex()?????????????????????????????????????	*/
				//u16 M8266WIFI_SPI_RecvData_ex(u8 Data[], u16 max_len, uint16_t max_wait_in_ms, u8* link_no, u8 remote_ip[4], u16* remote_port, u16* status)
				received = M8266WIFI_SPI_RecvData_ex(RecvData, RECV_DATA_MAX_SIZE, 5*1000, &link_no, remote_ip, &remote_port, &status);

				if(received != 0)	//?????????????????????????0???????????????
				{
					// ??16????????ip????????????????ip???????????????????????????????????????
					char dest_addr[15+1]={0};
					sprintf(dest_addr, "%d.%d.%d.%d", remote_ip[0], remote_ip[1], remote_ip[2], remote_ip[3]);

					u16 tcp_packet_size = 1024;
					u16 loops     = 0;
					u16 max_loops = 5000;
					u32 len       = received; 
				
					for(sent = 0, loops = 0; (sent < len) && (loops <= max_loops); loops++)
					{		
						#if ( TEST_CONNECTION_TYPE == 0 )  //if UDP??UDP???????????UDP??????????
							// ?????UDP?????????¡§????M8266WIFI_SPI_Send_Udp_Data()??????????????????????????????????????????????????????????UDP??????)
							// u16 M8266WIFI_SPI_Send_Udp_Data(u8 Data[], u16 Data_len, u8 link_no, char* udp_dest_addr, u16 udp_dest_port, u16* status)
							sent += M8266WIFI_SPI_Send_Udp_Data(RecvData+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no, dest_addr, remote_port, &status);
							
							if(sent>=len)  break;
							if((status&0xFF) == 0x00) { loops = 0; }
							else
							{
								if((status&0xFF) == 0x14)	// 0x14 = connection of link_no not present (????????????)
								{
									M8266HostIf_delay_us(99);
									//need to re-establish the socket connection (???????????????)
								}
								else { M8266HostIf_delay_us(250); }
							}         
						#elif ( TEST_CONNECTION_TYPE==2 )	//?????TCP???????????????¡§????M8266WIFI_SPI_Send_Data_to_TcpClient()???????????????????????????????????????????????????????????
							//u16 M8266WIFI_SPI_Send_Data_to_TcpClient(u8 Data[], u16 Data_len, u8 server_link_no, char* tcp_client_dest_addr, u16 tcp_client_dest_port, u16* status)
							sent += M8266WIFI_SPI_Send_Data_to_TcpClient(RecvData+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no, dest_addr, remote_port, &status);
							
							if(sent >= len)  break;
							if((status&0xFF) == 0x00) { loops = 0; }
							else
							{
								/*	0x14 = connection of link_no not present (????????????)
									0x15 = connection of link_no closed(????????????????)	*/
								if( ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )
								{
									M8266HostIf_delay_us(99);
									//need to re-establish the socket connection (???????????????)
								}
								// 0x18 = TCP server in listening states and no tcp clients have connected. (???TCP??????????¡ì¨¢????????????)
								else if( (status&0xFF) == 0x18 ) { M8266HostIf_delay_us(100); }
								else	{ M8266HostIf_delay_us(250); }
							}
						#endif						
					} // for(...
				} // if(received!=0)
			}
		} // while(1)


		#if 0	//link_no1
		link_no1 = 1;
		while(1)
		{
			if(M8266WIFI_SPI_Has_DataReceived()) // ????????????
			{
				/*	???????¡§????M8266WIFI_SPI_RecvData_ex()?????????????????????????????????????	*/
				//u16 M8266WIFI_SPI_RecvData_ex(u8 Data[], u16 max_len, uint16_t max_wait_in_ms, u8* link_no, u8 remote_ip[4], u16* remote_port, u16* status)
				received = M8266WIFI_SPI_RecvData_ex(RecvData, RECV_DATA_MAX_SIZE, 5*1000, &link_no1, remote_ip, &remote_port, &status);

				if(received != 0)	//?????????????????????????0???????????????
				{
					// ??16????????ip????????????????ip???????????????????????????????????????
					char dest_addr[15+1]={0};
					sprintf(dest_addr, "%d.%d.%d.%d", remote_ip[0], remote_ip[1], remote_ip[2], remote_ip[3]);

					u16 tcp_packet_size = 1024;
					u16 loops     = 0;
					u16 max_loops = 5000;
					u32 len       = received; 
				
					for(sent = 0, loops = 0; (sent < len) && (loops <= max_loops); loops++)
					{		
						#if ( TEST_CONNECTION_TYPE == 0 )  //if UDP??UDP???????????UDP??????????
							// ?????UDP?????????¡§????M8266WIFI_SPI_Send_Udp_Data()??????????????????????????????????????????????????????????UDP??????)
							// u16 M8266WIFI_SPI_Send_Udp_Data(u8 Data[], u16 Data_len, u8 link_no, char* udp_dest_addr, u16 udp_dest_port, u16* status)
							sent += M8266WIFI_SPI_Send_Udp_Data(RecvData+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no1, dest_addr, remote_port, &status);
							
							if(sent>=len)  break;
							if((status&0xFF) == 0x00) { loops = 0; }
							else
							{
								if((status&0xFF) == 0x14)	// 0x14 = connection of link_no1 not present (????????????)
								{
									M8266HostIf_delay_us(99);
									//need to re-establish the socket connection (???????????????)
								}
								else { M8266HostIf_delay_us(250); }
							}         
						#elif ( TEST_CONNECTION_TYPE==2 )	//?????TCP???????????????¡§????M8266WIFI_SPI_Send_Data_to_TcpClient()???????????????????????????????????????????????????????????
							//u16 M8266WIFI_SPI_Send_Data_to_TcpClient(u8 Data[], u16 Data_len, u8 server_link_no, char* tcp_client_dest_addr, u16 tcp_client_dest_port, u16* status)
							sent += M8266WIFI_SPI_Send_Data_to_TcpClient(RecvData+sent, ((len-sent)>tcp_packet_size)?tcp_packet_size:(len-sent), link_no1, dest_addr, remote_port, &status);
							
							if(sent >= len)  break;
							if((status&0xFF) == 0x00) { loops = 0; }
							else
							{
								/*	0x14 = connection of link_no1 not present (????????????)
									0x15 = connection of link_no1 closed(????????????????)	*/
								if( ((status&0xFF) == 0x14) || ((status&0xFF) == 0x15) )
								{
									M8266HostIf_delay_us(99);
									//need to re-establish the socket connection (???????????????)
								}
								// 0x18 = TCP server in listening states and no tcp clients have connected. (???TCP??????????¡ì¨¢????????????)
								else if( (status&0xFF) == 0x18 ) { M8266HostIf_delay_us(100); }
								else	{ M8266HostIf_delay_us(250); }
							}
						#endif						
					} // for(...
				} // if(received!=0)
			}
		} // while(1)
		#endif	//link_no1
	}


	//---------------------------------------------------------------------------
	//---------------------------------------------------------------------------
	#else	//TEST_M8266WIFI_TYPE != 1 2 3 4
	#error NOT Supported Test Type! should be 1~4!
	#endif

} // end of M8266WIFI_Test()
